## 객체지향 5원칙(SOLID)

로버트 마틴이 2000년대 초 명명한 객체 지향 프로그래밍의 다섯 가지 기본 원칙의 앞 글자를 따서 다시 SOLID라는 이름으로 소개한 것

- 단일 책임 원칙 (Single responsibility principle) : SRP
- 개방 폐쇄 원칙 (Open/closed principle) : OCP
- 리스코프 치환 원칙 (Liskov substitution principle) : LSP
- 인터페이스 분리 원칙 (Interface segregation principle) : ISP
- 의존관계 역전 원칙 (Dependency inversion principle) : DIP



### 5가지 핵심 원칙

1. 단일 책임의 원칙

   - 모든 클래스는 단 하나의 책임을 수행하는 데 집중되어야한다는 원칙입니다.
   - 다른 클래스들이 서로 영향을 미치는 연쇄작용을 줄일 수 있습니다.
   - 응집도는 높이고 결합도는 낮출 수 있습니다..
   - 책임을 적절하게 분배함으로써 코드의 가독성 향상, 유지보수 용이합니다.

2. 개방 폐쇄 원칙

   - 소프트웨어의 모든 구성요소(클래스, 모듈, 함수)는 확장에는 열려있고, 변경에는 닫혀있어야한다는 원칙입니다.
   - 기존 구성요소는 수정이 일어나지 말아야하며 쉽게 확장이 가능하여 재사용할 수 있어야 한다는 의미입니다.
   - 클래스를 설계할 때 변할 부분과 변하지 않을 부분을 명확히 구분할 필요가 있습니다.

3. 리스코프 치환 원칙

   - 부모 클래스를 가리키는 포인터에 해당 클래스를 상속하는 자식 클래스를 할당하더라도 모든 기능이 정상적으로 작동해야하며 자식 클래스의 상세 내부를 부모 클래스는 알 필요가 없다는 뜻입니다.

   - 즉, 부모 클래스를 상속한 자식 클래스는 부모 클래스의 역할을 정확히 해내야한다는 의미입니다.

   - 보통 부모 클래스의 메소드를 override하면서 문제가 발생합니다. 부모 클래스의 기존 메소드를 자식 클래스가 수정하면서 문제가 생기는 것입니다.

   - LSP를 지키는 가장 간단한 방법은 상속을 하되 override를 안하는 것입니다. 하지만 이게 무조건 적인 방법은 아닙니다.

     상속을 할 때 override가 필요하다면 기존 부모 클래스의 메소드가 하던 역할을 충실히 수행하고 기능의 추가만 신중하게 수행하면 됩니다.

     결국 상속의 과정 중 메소드의 재정의가 필요하다면 현재 **자식 클래스가 부모 클래스의 기존 메소드의 의미를 해치지는 않는지** 신중히 고민하고 올바르게 상속하라는 의미라고 생각합니다.

4. 인터페이스 분리 원칙

   - 자신이 사용하지 않는 인터페이스는 구현하지 말아야 한다는 원칙입니다.

   - 하나의 큰 인터페이스를 상속받기 보다는 인터페이스를 구체적이고 작은 단위들로 분리시켜 꼭 필요한 인터페이스만 상속하자는 의미입니다.

   - 인터페이스 하나의 크기가 크다는것은  한번에 지켜야할 약속이 많아진다는것을 의미합니다.

     \* 인터페이스: 서로 다른 두 개의 시스템, 장치 사이에서 정보나 신호를 주고받는 경우의 접점이나 경계면이다. 즉, 사용자가 기기를 쉽게 동작시키는데 도움을 주는 시스템을 의미한다.

5. 의존관계 역전 원칙

   - 상위 모듈은 하위 모듈에 의존해서는 안된다. 둘 다 추상화에 의존해야한다는 원칙입니다.
   - 클래스 사이에는 의존 관계가 있을수 있지만 최대한 추상화한 클래스에 의존하라는 의미입니다.