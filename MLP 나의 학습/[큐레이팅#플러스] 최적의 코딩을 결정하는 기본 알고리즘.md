# [큐레이팅#플러스] 최적의 코딩을 결정하는 기본 알고리즘

## 가장 기본이 되는 자료구조 : 스택과 큐

스택 자료구조

- 먼저 들어온 데이터가 나중에 나가는 형식의 자료구조
- 입구와 출구가 동일한 형태로 시각화 가능



큐 자료구조

- 먼저 들어온 데이터가 먼저 나가는 형식(선입 선출)의 자료구조
- 큐의 입구와 출구가 모두 뚫려있는 터널과 같은 형태로 시각화 가능



## 우선순위에 따라 데이터를 꺼내는 자료구조

우선순위 큐

- 우선순위가 가장 높은 데이터를 가장 먼저 삭제하는 자료구조

- 우선순위 큐는 데이터를 우선순위에 따라 처리하고 싶을 때 사용

  - ex) 물건 데이터를 자료구조에 넣었다가 가치가 높은 물건부터 꺼내 확인해야 하는 경우

- 우선순위 큐를 구현하는 방법

  - 단순히 리스트를 이용하여 구현
  - 힙(heap)을 이용하여 구현

- 데이터의 개수가 N개일 때, 구현 방식에 따라서 시간 복잡도를 비교한 내용은 다음과 같다.

  | 우선순위 큐 구현 방식 | 삽입 시간 | 삭제 시간 |
  | --------------------- | --------- | --------- |
  | 리스트                | O(1)      | O(N)      |
  | 힙(Heap)              | O(logN)   | O(logN)   |

- 단순히 N개의 데이터를 힙에 넣었다가 모두 꺼내는 작업은 정렬과 동일 ( 힙 정렬)

  - 이 경우 시간 복잡도는 O(NlogN)



힙(heap)의 특징

- 힙은 완전 이진 트리 자료구조의 일종
- 힙에서 항상 루트 노드(root node)를 제거
- 최소 힙(min heap)
  - 루트 노드가 가장 작은 값을 가집니다.
  - 따라서 값이 작은 데이터가 우선적으로 제거
- 최대 힙(max heap)
  - 루트 노드가 가장 큰 값을 가집니다.
  - 따라서 값이 큰 데이터가 우선적으로 제거



완전 이진 트리 (Complete Binary Tree)

- 완전 이진 트리란 루트(root) 노드부터 시작하여 왼쪽 자식 노드, 오른쪽 자식 노드 순서대로 데이터가 차례대로 삽입되는 트리(tree)를 의미



최소 힙 구성 함수 :  Min-Heapiify()

- (상향식) 부모 노드로 거슬러 올라가며, 부모보다 자신의 값이 더 작은 경우에 위치를 교체합니다.

- 힙에 새로운 원소가 삽입될 때 O(logN)의 시간 복잡도로 힙 성질을 유지하도록 할 수 있음.
- 힙에서 원소가 제거될 때 O(logN)의 시간 복잡도로 힙 성질을 유지하도록 할 수 있음
  - 원소를 제거할 떄는 가장 마지막 노드가 루트 노드의 위치에 오도록 합니다.
- 원소가 제거되었을 때 O(logN)의 시간 복잡도로 힙 성질을 유지하도록 할 수 있습니다.
  - 이후에 루트 노드에서부터 하향식으로(더 작은 자식 노드로) Heapify()를 진행합니다.





## 활용도가 높은 자료구조 : 트리 자료구조

트리

- 트리는 가계도와 같은 **계층적인 구조**를 표현할 떄 사용할 수 있는 자료구조

- 기본적으로 트리의 크기가 N일 때, 전체 간선의 개수는 N-1개입니다.

  | 용어                  | 의미                            |
  | --------------------- | ------------------------------- |
  | 루트 노드 (root node) | 부모가 없는 최상위 노드         |
  | 단말 노드 (leaf node) | 자식이 없는 노드                |
  | 크기 (size)           | 트리에 포함된 모든 노드의 개수  |
  | 깊이 (depth)          | 루트 노드부터의 거리            |
  | 높이 (height)         | 깊이 중 최댓값                  |
  | 차수 (degree)         | 각 노드의 (자식 방향) 간선 개수 |



이진 탐색 트리 (Binary Search Tree)

- 이진 탐색이 동작할 수 있도록 고안된 효율적인 탐색이 가능한 자료구조의 일종
- 이진 탐색 트리의 특징 : 왼쪽 자식 노드 < 부모 노드 < 오른쪽 자식 노드
  - 부모 노드보다 왼쪽 자식 노드가 작습니다.
  - 부모 노드보다 오른ㅉ쪽 자식 노드가 큽니다.

- 탐색 방법
  1. 루트 노드부터 방문하여 탐색을 진행
  2. 현재 노드와 값을 비교
  3. 현재 노드와 값을 비교



트리의 순회 (Tree Traversal)

- 트리 자료구조에 포함된 노드를 특정한 방법으로 한 번씩 방문하는 방법을 의미
  - 트리의 정보를 시각적으로 확인 가능
- 대표적인 트리 순회 방법은 다음과 같다.
  - 전위 순회(pre-order traverse) : 루트를 먽저 방문
  - 중위 순회(in-order traverse) : 왼쪽 자식을 방문한 뒤에 루트를 방문
  - 후위 순회(post-order traverse) : 오른쪽 자식을 방문한 뒤에 루트를 방문



## 데이터 업데이트가 가능한 상황에서의 구간 합(Interval Sum) 문제

바이너리 인덱스 트리(binary indexed tree)는 2진법 인덱스 구조를 활용해 구간 합 문제를 효과적으로 해결해 줄 수 있는 자료구조를 의미

- 펜윅 트리(fenwick tree)라고도 함.

0이 아닌 마지막 비트를 찾는 방법

- 특정한 숫자 K의 0이 아닌 마지막 비트를 찾기 위해서는 K&-K를 계산하면 됨.



바이너리 인덱스 트리: 업데이트 (Update)

- 특정 값을 변경할 때: 0이 아닌 마지막 비트만큼 더하면서 구간들의 값을 변경

바이너리 인덱스 트리: 누적 합(Prefix Sum)

- 1부터 N까지의 합(누적 합) 구하기: 0이 아닌 마지막 비트만큼 빼면서 구간들의 값의 합 계산





## 정렬 알고리즘

- 정렬(Sorting)이란 **데이터를 특정한 기준에 따라 순서대로 나열하는 것**을 말합니다.
- 일반적으로 문제 상황에 따라서 적절한 정렬 알고리즘이 공식처럼 사용됩니다.



선택 정렬

- 처리되지 않은 데이터 중에서 *가장 작은 데이터를 **선택**해 맨 앞에 있는 데이터와 바꾸는 것을 반복*합니다.
- 시간 복잡도
  - 선택 정렬은 N번 만큼 가장 작은 수를 찾아서 맨 앞으로 보내야 합니다.
  - 구현 방식에 따라서 사소한 오차는 있을 수 있지만, 전체 연산 횟수는 다음과 같습니다.
  - N + (N - 1) + (N - 2) +... +2
  - 이는 (N의 제곱 + N - 2)/2로 표현할 수 있는데, 빅오 표기법에 따라서 O(N의 제곱)이라고 작성한다.



삽입 정렬 

- 처리되지 않은 데이터를 하나씩 골라 적절한 위치에 삽입
- 선택 정렬에 비해 구현 난이도가 높은 편이지만, 일반적으로 더 효율적으로 동작합니다.
- 시간 복잡도
  - 삽입 정렬의 시간 복잡도는 O(N의 제곱)이며, 선택 정렬과 마찬가지로 반복문이 두 번 중첩되어 사용됩니다.
  - 삽입 정렬은 현재 리스트의 데이터가 거의 정렬되어 있는 상태라면 매우 빠르게 동작합니다
    - 최선의 경우 O(N)의 시간 복잡도를 가집니다.



퀵 정렬

- *기준 데이터를 설정*하고 그 **기준보다 큰 데이터와 작은 데이터의 위치를 바꾸는 방법**입니다.
- 일반적인 상황에서 가장 많이 사용되는 정렬 알고리즘 중 하나입니다.
- 병합 정렬과 더불어 대부분의 프로그래밍 언어의 정렬 라이브러리의 근간이 되는 알고리즘입니다.
- 가장 기본적인 퀵 정렬은 **첫 번째 데이터를 기준 데이터(Pivot)로 설정**합니다.
- 빠른 이유
  - 이상ㅈ적인 경우 분할이 절반씩 일어난다면 전체 연산 횟수로 O(NlogN)를 기대할 수 있습니다.
    - 너비 * 높이 = N * logN = NlogN
- 시간 복잡도
  - 퀵 정렬은 평균의 경우 O(NlogN)의 시간 복잡도를 가집니다.
  - 하지만 최악의 경우 O(N의 제곱)의 시간 복잡도를 가집니다.



계수 정렬

- 특정한 조건이 부합할 때만 사용할 수 있지만 **매우 빠르게 동작하는** 정렬 알고리즘입니다.
  - 계수 정렬은 *데이터의 크기 범위가 제한되어 정수 형태로 표현할 수 있을 때* 사용 가능합니다.
- 데이터의 개수가 N, 데이터(양수) 중 최댓값이 K일 때 최악의 경우에도 수행 시간 O(N+K)를 보장합니다.
- 계수 정렬의 시간 복잡도와 공간 복잡도는 모두 O(N+K)입니다.
- 계수 정렬은 때에 따라서 심각한 비효율성을 초래할 수 있습니다.
- 계수 정렬은 동인한 값을 가지는 데이터가 여러 개 등장할 때 효과적으로 사용할 수 있습니다.

| 정렬 알고리즘 | 평균 시간 복잡도 | 공간 복잡도 | 특징                                                         |
| ------------- | ---------------- | ----------- | ------------------------------------------------------------ |
| 선택 정렬     | O(N의 제곱       | O(N)        | 아이디어가 매우 간단합니다.                                  |
| 삽입 정렬     | O(N의 제곱)      | O(N)        | 데이터가 거의 정렬되어 있을 때는 가장 빠릅니다.              |
| 퀵 정렬       | O(NlogN)         | O(N)        | 대부분의 경우에 가장 적합하며, 충분히 빠릅니다               |
| 계수 정렬     | O(N + K)         | O(N + K)    | 데이터의 크기가 한정되어 있는 경우에만 사용이 가능하지만 매우 빠르게 동작합니다. |

추가적으로 대부분의 프로그래밍 언어에서 지원하는 **표준 정렬 라이브러리는 최악의 경우에도 O(NlogN)을 보장**하도록 설계되어 있습니다.
